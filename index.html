<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Market Explorer (Polymarket & Myriad)</title>
<style>
  body { font-family: system-ui, Arial, sans-serif; margin: 16px; }
  h1 { margin: 0 0 12px; }
  .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
  input,button,select { padding:6px 8px; font-size:14px; }
  table { width:100%; border-collapse: collapse; }
  th,td { border-bottom:1px solid #ddd; padding:8px; text-align:left; vertical-align:top; }
  .muted{ opacity:.7; font-size:12px; }
  .token{ display:inline-block; font-family:ui-monospace,Menlo,monospace; font-size:12px; background:#f5f5f5; padding:2px 6px; border-radius:6px; margin:2px 4px 2px 0; }
  .chip{ display:inline-block; padding:2px 6px; border-radius:999px; background:#e8f8e8; font-size:12px; margin-left:6px; }
  .ladder{ display:grid; grid-template-columns:120px 120px; gap:10px; margin-top:6px; }
  .mini { font-size:12px; width:100%; border-collapse: collapse; margin-top:4px; }
  .mini th,.mini td{ border-bottom:1px dashed #eee; padding:4px 6px; }
  details { margin-top:6px; }
  .nowrap{ white-space:nowrap; }
  code { background:#f7f7f7; padding:2px 4px; border-radius:4px; }
  .pill { display:inline-block; padding:2px 6px; border-radius:999px; background:#f3f3ff; font-size:12px; margin-left:6px; }
  .danger { background:#fee; border:1px solid #f99; }
</style>
</head>
<body>
<h1>Market Explorer <span class="muted">(Polymarket & Myriad)</span></h1>

<div class="controls">
  <label>Source:
    <select id="source">
      <option value="poly" selected>Polymarket</option>
      <option value="myriad">Myriad (Polkamarkets)</option>
    </select>
  </label>
  <label>Filter: <input id="q" placeholder="type to filter by question/slug/title" /></label>
  <label>Page size:
    <select id="pageSize"><option>25</option><option>50</option><option selected>100</option><option>200</option></select>
  </label>
  <button id="refreshBtn">Refresh</button>
  <span id="status" class="muted"></span>
</div>

<table>
  <thead><tr><th>Question / Title</th><th class="nowrap">Market ID</th><th>Tokens / Prices</th></tr></thead>
  <tbody id="tbody"></tbody>
</table>

<div class="controls">
  <button id="prevBtn">← Prev</button>
  <span id="pageInfo" class="muted"></span>
  <button id="nextBtn">Next →</button>
</div>

<!-- ======================= Catalog (search by name + persist) ======================= -->
<hr/>
<div id="catalog">
  <h3>Catalog <span class="muted">(search by name; persisted locally)</span></h3>
  <div class="controls">
    <button id="catSave">Save current lists to browser</button>
    <button id="catLoad">Load from browser</button>
    <button id="catExport">Download JSON</button>
    <span id="catMsg" class="muted"></span>
  </div>
  <div class="controls">
    <label>Find Polymarket:
      <input id="catFindPoly" list="polyList" placeholder="search question/slug"/>
      <datalist id="polyList"></datalist>
    </label>
    <button id="catUsePoly">Use → Polymarket ID</button>

    <label>Find Myriad:
      <input id="catFindMyriad" list="myrList" placeholder="search title/slug"/>
      <datalist id="myrList"></datalist>
    </label>
    <button id="catUseMyriad">Use → Myriad ID</button>
  </div>
  <div class="muted">Tip: Use the finder after you’ve loaded each source (Polymarket / Myriad) so the catalog has fresh items.</div>
</div>

<!-- ======================= Pairs Admin ======================= -->
<hr/>
<div id="pairs-admin" style="margin-top:16px;">
  <h3>Pairs Admin <span class="muted">(Polymarket ↔ Myriad)</span></h3>
  <div class="controls">
    <label>Worker:
      <input id="pairBase" value="https://arbarbarb.rihardschnr2.workers.dev" style="width:360px;">
    </label>
    <label>Admin token:
      <input id="pairTok" type="password" placeholder="paste ADMIN_TOKEN" style="width:260px;">
    </label>
    <button id="pairUse">Use in this tab</button>
    <span id="pairAuthMsg" class="muted"></span>
  </div>

  <div class="controls">
    <label>Polymarket ID: <input id="pairPoly" placeholder="e.g. 516710" style="width:160px;"></label>
    <label>Myriad ID: <input id="pairMyriad" placeholder="e.g. 134" style="width:160px;"></label>
    <label>Direction:
      <select id="pairDir">
        <option value="same">same</option>
        <option value="inverse">inverse</option>
      </select>
    </label>
  </div>

  <div class="controls">
    <label>Outcome map (JSON):
      <input id="pairMap" placeholder='[{"poly":"Yes","myriad":"≥ $125K"},{"poly":"No","myriad":"≤ $105K"}]' style="width:560px;">
    </label>
    <label>Notes: <input id="pairNotes" style="width:260px;"></label>
  </div>

  <div class="controls">
    <button id="pairBuildMap">Build map from choices…</button>
    <button id="pairCreate">Create</button>
    <button id="pairUpsert">Upsert</button>
    <button id="pairDelete" class="danger">Delete</button>
    <button id="pairRefresh">Refresh list</button>
    <span id="pairMsg" class="muted"></span>
  </div>

  <details id="mapBuilder" style="margin:8px 0; display:none;">
    <summary><b>Outcome Map Builder</b> <span class="muted">(loads choices, lets you pair them)</span></summary>
    <div id="mapBuilderInner" style="margin-top:8px; padding:8px; background:#fafafa; border:1px solid #eee; border-radius:8px;">Loading…</div>
  </details>

  <table class="mini" style="width:100%; margin-top:10px;">
    <thead><tr><th>Polymarket</th><th>Myriad</th><th>Dir</th><th>Map</th><th>Notes</th><th>Updated</th><th></th></tr></thead>
    <tbody id="pairTable"></tbody>
  </table>
</div>

<script>
// ---------- Config
const PROXY = "https://arbarbarb.rihardschnr2.workers.dev/"; // your Cloudflare Worker
const GAMMA = "https://gamma-api.polymarket.com";
const CLOB  = "https://clob.polymarket.com";
const MYRIAD_BASE   = "https://api-production.polkamarkets.com/markets";
const MYRIAD_PARAMS = "network_id=274133&state=open&land_ids=myriad-szn2-usdc-v33&per_page=100";

// ---------- Proxy fetch (uses Worker)
async function xfetch(url,{retries=4,backoff=500}={}){
  const bust=`_=${Date.now()}`;
  const proxied = `${PROXY}?url=${encodeURIComponent(url)}&${bust}`;
  for(let a=0;a<retries;a++){
    const r = await fetch(proxied, { method:"GET", cache:"no-store" });
    if(r.status===429){ await new Promise(res=>setTimeout(res, backoff*(2**a))); continue; }
    if(!r.ok) throw new Error(`Proxy HTTP ${r.status} for ${url}`);
    const ct = r.headers.get("content-type")||"";
    return ct.includes("application/json") ? r.json() : r.text();
  }
  throw new Error(`Retry limit reached for ${url}`);
}

// ---------- State
let RAW=[], VIEW=[], BY_ID={}, page=0;
const sourceEl=document.getElementById('source');
const qEl=document.getElementById('q');
const pageSizeEl=document.getElementById('pageSize');
const statusEl=document.getElementById('status');
const tbody=document.getElementById('tbody');
const pageInfo=document.getElementById('pageInfo');

// Catalog state (persisted)
const CKEY = "CATALOG_V1"; // {poly:[], myriad:[]}
let CATALOG = { poly: [], myriad: [] };

// ---------- UI wiring
document.getElementById('refreshBtn').onclick = load; // ONLY fetch when Refresh is clicked
document.getElementById('prevBtn').onclick = () => { if (page>0){ page--; render(); } };
document.getElementById('nextBtn').onclick = () => { if ((page+1)*pageSize() < VIEW.length){ page++; render(); } };
qEl.oninput = applyFilter;
pageSizeEl.onchange = () => { page=0; render(); };
sourceEl.onchange = () => setStatus(`Source set to ${sourceEl.value === 'poly' ? 'Polymarket' : 'Myriad'} — press Refresh to load.`);

// ---------- Utils
function pageSize(){ return parseInt(pageSizeEl.value,10)||100; }
function parseIso(s){ const d=s?new Date(s):null; return isFinite(d)?d:null; }
function escapeHtml(s){ return (s||"").replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
function setStatus(s){ statusEl.textContent=s; }
function today(){ const d=new Date(); d.setHours(0,0,0,0); return d; }
const nf = (x,dp=2)=> (x==null?'—':Number(x).toLocaleString(undefined,{maximumFractionDigits:dp}));
const pf = (x,dp=6)=> (x==null?'—':Number(x).toFixed(dp));

// ---------- Catalog helpers
function saveCatalog() {
  try { localStorage.setItem(CKEY, JSON.stringify(CATALOG)); return true; } catch { return false; }
}
function loadCatalog() {
  try { const j = JSON.parse(localStorage.getItem(CKEY)||"{}"); CATALOG = { poly:j.poly||[], myriad:j.myriad||[] }; } catch { CATALOG={poly:[],myriad:[]}; }
  refreshDatalists();
}
function refreshDatalists(){
  // Polymarket
  const pl = document.getElementById('polyList');
  pl.innerHTML = "";
  CATALOG.poly.forEach(m=>{
    const opt = document.createElement('option');
    opt.value = `${m.id}|${m.question}`;
    opt.label = `${m.id} — ${m.question}  (${m.slug||''})`;
    pl.appendChild(opt);
  });
  // Myriad
  const ml = document.getElementById('myrList');
  ml.innerHTML = "";
  CATALOG.myriad.forEach(m=>{
    const opt = document.createElement('option');
    opt.value = `${m.id}|${m.title}`;
    opt.label = `${m.id} — ${m.title}  (${m.slug||''})`;
    ml.appendChild(opt);
  });
}
function updateCatalogFromRaw(source) {
  if (source === 'poly') {
    const add = RAW.map(m => ({ id:String(m.id), question:m.question, slug:m.slug||"" }));
    const seen = new Set(CATALOG.poly.map(x=>x.id));
    add.forEach(x=>{ if(!seen.has(x.id)) CATALOG.poly.push(x); });
  } else {
    const add = RAW.map(m => ({ id:String(m.id), title:m.question, slug:m.slug||"" }));
    const seen = new Set(CATALOG.myriad.map(x=>x.id));
    add.forEach(x=>{ if(!seen.has(x.id)) CATALOG.myriad.push(x); });
  }
  refreshDatalists();
}

// ---------- Polymarket loaders
async function fetchAllClobMarkets(){
  let cursor=""; const out=[];
  while(true){
    const url=`${CLOB}/markets${cursor?`?next_cursor=${encodeURIComponent(cursor)}`:""}`;
    const data = await xfetch(url);
    const arr = data?.data || [];
    out.push(...arr);
    cursor = data?.next_cursor;
    setStatus(`Polymarket CLOB: ${out.length} markets loaded…`);
    if(!cursor || cursor==="LTE=") break;
    await new Promise(r=>setTimeout(r,200));
  }
  return out;
}
async function fetchAllGammaOpen(){
  const limit=1000; let offset=0; const out=[];
  while(true){
    const url=`${GAMMA}/markets?closed=false&limit=${limit}&offset=${offset}`;
    const chunk = await xfetch(url);
    if(!Array.isArray(chunk)||chunk.length===0) break;
    out.push(...chunk);
    offset+=chunk.length;
    setStatus(`Polymarket Gamma: ${out.length} open markets loaded…`);
    if(chunk.length<limit) break;
    await new Promise(r=>setTimeout(r,50));
  }
  return out;
}
async function loadPolymarket(){
  const [clob,gamma]=await Promise.all([fetchAllClobMarkets(), fetchAllGammaOpen()]);
  const byCond=new Map();
  for(const m of clob){
    const k=(m.conditionId||m.condition_id||m.condition_hash||"").toLowerCase();
    if(k) byCond.set(k,m);
  }
  const now=today();
  RAW = gamma
    .filter(g => { const end=parseIso(g.endDateIso||g.endDate); return !end || end >= now; })
    .map(g=>{
      const condKey=String(g.conditionId||g.questionID||"").toLowerCase();
      const cm=byCond.get(condKey)||{};
      return {
        src:"poly",
        id:g.id, question:g.question, slug:g.slug,
        endDateIso:g.endDateIso||g.endDate,
        active:g.active, closed:g.closed,
        outcomes:g.outcomes, clobTokenIds:g.clobTokenIds,
        bestBid:g.bestBid, bestAsk:g.bestAsk,
        clob:cm
      };
    })
    .sort((a,b)=>{
      const ea=parseIso(a.endDateIso)?.getTime()??Infinity;
      const eb=parseIso(b.endDateIso)?.getTime()??Infinity;
      return ea-eb;
    });
  BY_ID = Object.fromEntries(RAW.map(m=>[String(m.id), m]));
  setStatus(`Polymarket: ${RAW.length} open, unexpired markets.`);
  updateCatalogFromRaw('poly'); // << add to catalog
  applyFilter();
}

// ---------- Myriad loader
async function loadMyriad(){
  const now = today();
  const perPage = 100;
  let pageNum = 1;
  const all = [];

  try {
    while (true) {
      const url = `${MYRIAD_BASE}?${MYRIAD_PARAMS}&page=${pageNum}`;
      const resp = await xfetch(url);
      const chunk = Array.isArray(resp) ? resp : (Array.isArray(resp?.data) ? resp.data : []);
      setStatus(`Myriad: page ${pageNum} → ${chunk.length} markets`);
      if (!chunk.length) break;
      all.push(...chunk);
      if (chunk.length < perPage) break; // no more pages
      pageNum++;
      await new Promise(r => setTimeout(r, 80));
    }
  } catch (e) {
    console.error("Myriad fetch via Worker failed:", e);
    setStatus(`Myriad fetch via Worker failed: ${e?.message || e}`);
    return;
  }

  RAW = all
    .filter(m => m?.state === "open")
    .filter(m => { const end = parseIso(m.expires_at); return !end || end >= now; })
    .map(m => ({
      src: "myriad",
      id: m.id, question: m.title, slug: m.slug,
      endDateIso: m.expires_at,
      active: true, closed: false,
      liquidity: m.liquidity, volume: m.volume, volume24h: m.volume_24h,
      users: m.users, tokenSymbol: m?.token?.symbol || "",
      resolution_source: m.resolution_source || "",
      outcomes: Array.isArray(m.outcomes) ? m.outcomes : [],
      raw: m
    }))
    .sort((a,b)=>{
      const ea = parseIso(a.endDateIso)?.getTime() ?? Infinity;
      const eb = parseIso(b.endDateIso)?.getTime() ?? Infinity;
      return ea - eb;
    });

  BY_ID = Object.fromEntries(RAW.map(m => [String(m.id), m]));
  setStatus(`Myriad: ${RAW.length} open, unexpired markets.`);
  updateCatalogFromRaw('myriad'); // << add to catalog
  applyFilter();
}

// ---------- Master loader (manual only)
async function load(){
  setStatus("Loading…");
  try{
    if(sourceEl.value==="poly"){ await loadPolymarket(); }
    else { await loadMyriad(); }
  }catch(e){
    console.error(e);
    setStatus(`Failed to load: ${e?.message||e}`);
  }
}

// ---------- Filter + render
function applyFilter(){
  const q=(qEl.value||"").toLowerCase();
  VIEW = RAW.filter(m => (`${m.question} ${m.slug}`.toLowerCase()).includes(q));
  page=0; render();
}
function render(){
  tbody.innerHTML="";
  const ps=pageSize();
  const slice=VIEW.slice(page*ps,page*ps+ps);

  for(const m of slice){
    const tr=document.createElement('tr');

    const tdQ=document.createElement('td');
    const end=parseIso(m.endDateIso);
    const endTxt=end?new Intl.DateTimeFormat(undefined,{year:'numeric',month:'short',day:'numeric'}).format(end):'';
    const chip=`<span class="chip">${m.src==="poly"?"Polymarket":"Myriad"}</span>`;
    tdQ.innerHTML=`<div>${escapeHtml(m.question)} ${chip}</div>
                   <div class="muted">${escapeHtml(m.slug||'')} ${endTxt?` · ends ${endTxt}`:''}</div>`;
    tr.appendChild(tdQ);

    const tdId=document.createElement('td'); tdId.textContent=m.id; tr.appendChild(tdId);

    const tdTok=document.createElement('td');
    if(m.src==="poly"){
      tdTok.innerHTML = `
        <div class="muted">Best: ${m.bestBid!=null?pf(m.bestBid,2):'—'} / ${m.bestAsk!=null?pf(m.bestAsk,2):'—'}</div>
        <div style="margin-top:6px;">
          <button data-load-tokens="${m.id}">Load options</button>
          <button data-view-json="${m.id}">View JSON</button>
        </div>
        <div id="tokens-${m.id}" class="muted" style="margin-top:6px;">—</div>
        <div id="json-${m.id}" class="muted" style="margin-top:6px; display:none;"></div>
      `;
    } else {
      const liq = nf(m.liquidity);
      const vol = nf(m.volume);
      const vol24 = nf(m.volume24h);
      const users = m.users!=null ? Number(m.users).toLocaleString() : '—';
      tdTok.innerHTML = `
        <div class="muted">Token: ${escapeHtml(m.tokenSymbol||'—')} · Users: ${users}</div>
        <div class="muted">Liquidity: ${liq} · 24h Vol: ${vol24} · Total Vol: ${vol}</div>
        <div style="margin-top:6px;">
          ${m.resolution_source ? `<a href="${m.resolution_source}" target="_blank" rel="noopener">Resolution source ↗</a>` : ''}
          <button data-myriad-options="${m.id}" style="margin-left:8px;">Load options</button>
          <button data-view-json="${m.id}" style="margin-left:8px;">View JSON</button>
        </div>
        <div id="mopts-${m.id}" class="muted" style="margin-top:6px;">—</div>
        <div id="json-${m.id}" class="muted" style="margin-top:6px; display:none;"></div>
      `;
    }
    tr.appendChild(tdTok);
    tbody.appendChild(tr);
  }

  pageInfo.textContent = `Page ${VIEW.length ? page+1 : 0} of ${Math.ceil(VIEW.length/ps)} — ${VIEW.length} shown`;

  // Wire buttons
  tbody.querySelectorAll('button[data-load-tokens]').forEach(btn=>{
    btn.onclick = () => loadPolyTokens(btn.getAttribute('data-load-tokens'));
  });
  tbody.querySelectorAll('button[data-myriad-options]').forEach(btn=>{
    btn.onclick = () => loadMyriadOptions(btn.getAttribute('data-myriad-options'));
  });
  tbody.querySelectorAll('button[data-view-json]').forEach(btn=>{
    btn.onclick = () => toggleJson(btn.getAttribute('data-view-json'));
  });
}

// ---------- Polymarket tokens + order book (via Worker)
async function loadPolyTokens(marketId){
  const host=document.getElementById(`tokens-${marketId}`);
  if(!host) return;
  host.textContent="Loading options…";
  const meta=BY_ID[String(marketId)]||{};
  try{
    let tokens=[], detail=null;
    try{ detail=await xfetch(`${CLOB}/markets/${marketId}`);}catch(_){}
    if(detail && Array.isArray(detail.tokens) && detail.tokens.length){
      tokens=detail.tokens.map(t=>({id:t.id||t.token_id,label:t.name||t.label||t.ticker||t.outcome||'Outcome'}));
    }else{
      const ids=typeof meta.clobTokenIds==='string'?JSON.parse(meta.clobTokenIds):(meta.clobTokenIds||[]);
      const outs=typeof meta.outcomes==='string'?JSON.parse(meta.outcomes):(meta.outcomes||[]);
      tokens=ids.map((tid,i)=>({id:String(tid),label:String(outs[i]??`Outcome ${i+1}`)}));
    }
    if(!tokens.length){ host.textContent="No tokens found for this market."; return; }

    const tbl=document.createElement('table'); tbl.className='mini';
    tbl.innerHTML=`<thead><tr><th>Outcome</th><th>Token</th><th>Best bid</th><th>Best ask</th><th></th></tr></thead><tbody></tbody>`;
    const body=tbl.querySelector('tbody');

    for(const t of tokens){
      const tr=document.createElement('tr');
      tr.innerHTML=`<td>${escapeHtml(t.label)}</td>
        <td><span class="token">${t.id}</span></td>
        <td id="bb-${t.id}" class="muted">…</td>
        <td id="ba-${t.id}" class="muted">…</td>
        <td><button data-view-book="${t.id}">View book</button></td>`;
      body.appendChild(tr);

      xfetch(`${CLOB}/book?token_id=${encodeURIComponent(t.id)}`).then(book=>{
        document.getElementById(`bb-${t.id}`).textContent = book?.bids?.[0]?.price?.toFixed(4) ?? '—';
        document.getElementById(`ba-${t.id}`).textContent = book?.asks?.[0]?.price?.toFixed(4) ?? '—';
      }).catch(_=>{
        document.getElementById(`bb-${t.id}`).textContent='—';
        document.getElementById(`ba-${t.id}`).textContent='—';
      });
    }
    host.innerHTML=""; host.appendChild(tbl);
    host.querySelectorAll('button[data-view-book]').forEach(btn=>{
      btn.onclick=()=>viewBook(btn.getAttribute('data-view-book'),host);
    });
  }catch(e){ console.error(e); host.textContent="Failed to load options for this market."; }
}

async function viewBook(tokenId, host){
  let existing=document.getElementById(`bookwrap-${tokenId}`);
  if(existing){ existing.open=!existing.open; return; }
  const det=document.createElement('details'); det.id=`bookwrap-${tokenId}`; det.open=true;
  det.innerHTML=`<summary>Order book for ${tokenId}</summary><div id="book-${tokenId}" class="ladder">Loading…</div>`;
  host.appendChild(det);
  try{
    const book=await xfetch(`${CLOB}/book?token_id=${encodeURIComponent(tokenId)}`);
    const bids=(book?.bids||[]).slice(0,15).map(b=>`${Number(b.price).toFixed(4)} @ ${Number(b.size).toFixed(4)}`).join('<br/>')||'—';
    const asks=(book?.asks||[]).slice(0,15).map(a=>`${Number(a.price).toFixed(4)} @ ${Number(a.size).toFixed(4)}`).join('<br/>')||'—';
    document.getElementById(`book-${tokenId}`).innerHTML = `<div><b>Bids (top 15)</b><br/>${bids}</div><div><b>Asks (top 15)</b><br/>${asks}</div>`;
  }catch(e){ console.error(e); document.getElementById(`book-${tokenId}`).textContent="Failed to load book."; }
}

// ---------- Myriad options (robust)
async function loadMyriadOptions(marketId){
  const host = document.getElementById(`mopts-${marketId}`);
  if(!host) return;
  host.textContent = "Loading options…";

  try {
    const m = BY_ID[String(marketId)] || {};
    let outcomes = Array.isArray(m.outcomes) ? m.outcomes : [];

    // Fallback 1: detail endpoint
    if (!outcomes.length) {
      const detail = await xfetch(`${MYRIAD_BASE}/${marketId}?network_id=274133`);
      const obj = detail && detail.data ? detail.data : detail;
      if (Array.isArray(obj?.outcomes)) outcomes = obj.outcomes;
    }

    // Fallback 2: explicit outcomes endpoint
    if (!outcomes.length) {
      const maybe = await xfetch(`${MYRIAD_BASE}/${marketId}/outcomes?network_id=274133`);
      const arr = Array.isArray(maybe) ? maybe : (Array.isArray(maybe?.data) ? maybe.data : []);
      if (arr.length) outcomes = arr;
    }

    if (!outcomes.length) {
      host.textContent = "No options found for this market.";
      return;
    }

    const tbl = document.createElement('table');
    tbl.className = 'mini';
    tbl.innerHTML = `
      <thead><tr><th>Outcome</th><th>Price</th><th>Shares</th><th>Holders</th></tr></thead>
      <tbody></tbody>
    `;
    const body = tbl.querySelector('tbody');

    for (const o of outcomes) {
      const title = o.title || o.name || `Outcome ${o.id ?? ''}`.trim();
      const price = pf(o.price, 6);
      const shares = nf(o.shares ?? o.shares_held, 4);
      const holders = o.holders != null ? Number(o.holders).toLocaleString() : '—';
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${escapeHtml(title)}</td><td>${price}</td><td>${shares}</td><td>${holders}</td>`;
      body.appendChild(tr);
    }

    host.innerHTML = "";
    host.appendChild(tbl);
  } catch (e) {
    console.error(e);
    host.textContent = "Failed to load options for this market.";
  }
}

// ---------- JSON peek
function toggleJson(id){
  const el=document.getElementById(`json-${id}`); if(!el) return;
  if(el.style.display==="none"){
    const m=BY_ID[String(id)];
    el.textContent = JSON.stringify(m.src==="poly"?m:m.raw, null, 2);
    el.style.display="block";
  }else{
    el.style.display="none";
  }
}

// ---------- Catalog UI wiring
const catMsg = document.getElementById('catMsg');
document.getElementById('catSave').onclick = ()=>{
  const ok = saveCatalog();
  catMsg.textContent = ok ? "Saved to your browser." : "Save failed.";
};
document.getElementById('catLoad').onclick = ()=>{
  loadCatalog(); catMsg.textContent = `Loaded ${CATALOG.poly.length} poly, ${CATALOG.myriad.length} myriad.`;
};
document.getElementById('catExport').onclick = ()=>{
  const blob = new Blob([JSON.stringify(CATALOG,null,2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob); a.download = 'market-catalog.json'; a.click();
};
document.getElementById('catUsePoly').onclick = ()=>{
  const v = document.getElementById('catFindPoly').value.trim();
  const id = v.split('|')[0].trim();
  if(id) document.getElementById('pairPoly').value = id;
};
document.getElementById('catUseMyriad').onclick = ()=>{
  const v = document.getElementById('catFindMyriad').value.trim();
  const id = v.split('|')[0].trim();
  if(id) document.getElementById('pairMyriad').value = id;
};
loadCatalog(); // prefill lists on load

// ---------- Pairs Admin (calls your Worker /pairs …)
(function(){
  const el = (id)=>document.getElementById(id);
  const sset = (k,v)=>sessionStorage.setItem(k,v);
  const sget = (k)=>sessionStorage.getItem(k)||"";
  const ok = (n,t)=>{ n.textContent=t; n.style.color="#137333"; };
  const err = (n,t)=>{ n.textContent=t; n.style.color="#B00020"; };

  const baseEl = el('pairBase'), tokEl = el('pairTok'), useBtn = el('pairUse'), authMsg = el('pairAuthMsg');
  const polyEl = el('pairPoly'), myrEl = el('pairMyriad'), dirEl = el('pairDir'), mapEl = el('pairMap'), notesEl = el('pairNotes');
  const createBtn = el('pairCreate'), upsertBtn = el('pairUpsert'), delBtn = el('pairDelete'), refBtn = el('pairRefresh');
  const msgEl = el('pairMsg'), tbl = el('pairTable');
  const buildBtn = el('pairBuildMap'), mapWrap = el('mapBuilder'), mapInner = el('mapBuilderInner');

  baseEl.value = sget('PAIR_BASE') || baseEl.value;
  tokEl.value = sget('PAIR_TOKEN') || "";

  useBtn.onclick = ()=>{ sset('PAIR_BASE', baseEl.value.trim()); sset('PAIR_TOKEN', tokEl.value.trim()); ok(authMsg,"Token set for this tab."); };

  async function call(method, path, body){
    const url = baseEl.value.replace(/\/+$/,'') + path;
    const r = await fetch(url, {
      method,
      headers: {
        'Content-Type':'application/json',
        'Authorization': 'Bearer ' + (sget('PAIR_TOKEN')||''),
      },
      body: body ? JSON.stringify(body) : undefined
    });
    const ct = r.headers.get('content-type')||'';
    const data = ct.includes('json') ? await r.json() : await r.text();
    if(!r.ok) throw new Error((data && data.error) || r.statusText);
    return data;
  }

  function parseMap(){
    const t = mapEl.value.trim();
    if(!t) return [];
    try { const j = JSON.parse(t); return Array.isArray(j)?j:[]; } catch(e){ throw new Error('Invalid outcome map JSON'); }
  }

  async function create(){
    try{
      const payload = {
        polyId: polyEl.value.trim(),
        myriadId: myrEl.value.trim(),
        direction: dirEl.value,
        map: parseMap(),
        notes: notesEl.value.trim(),
      };
      if(!payload.polyId || !payload.myriadId) throw new Error('polyId and myriadId required');
      await call('POST','/admin/pairs', payload);
      ok(msgEl,'Created.'); await refresh();
    }catch(e){ err(msgEl,e.message); }
  }
  async function upsert(){
    try{
      const polyId = polyEl.value.trim(), myriadId = myrEl.value.trim();
      if(!polyId || !myriadId) throw new Error('polyId and myriadId required');
      await call('PUT', `/admin/pairs/${encodeURIComponent(polyId)}/${encodeURIComponent(myriadId)}`, {
        direction: dirEl.value, map: parseMap(), notes: notesEl.value.trim()
      });
      ok(msgEl,'Upserted.'); await refresh();
    }catch(e){ err(msgEl,e.message); }
  }
  async function del(){
    try{
      const polyId = polyEl.value.trim(), myriadId = myrEl.value.trim();
      if(!polyId || !myriadId) throw new Error('polyId and myriadId required');
      await call('DELETE', `/admin/pairs/${encodeURIComponent(polyId)}/${encodeURIComponent(myriadId)}`);
      ok(msgEl,'Deleted.'); await refresh();
    }catch(e){ err(msgEl,e.message); }
  }
  async function refresh(){
    try{
      msgEl.textContent = 'Loading…';
      const data = await fetch(baseEl.value.replace(/\/+$/,'') + '/pairs').then(r=>r.json());
      const pairs = data.pairs || [];
      tbl.innerHTML = '';
      for(const p of pairs){
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${p.polyId}</td>
          <td>${p.myriadId}</td>
          <td>${p.direction||'same'}</td>
          <td><code>${JSON.stringify(p.map||[])}</code></td>
          <td>${p.notes||''}</td>
          <td class="muted">${p.at||''}</td>
          <td><button data-edit="${p.polyId}|${p.myriadId}">Edit</button></td>`;
        tbl.appendChild(tr);
      }
      tbl.querySelectorAll('button[data-edit]').forEach(btn=>{
        btn.onclick = ()=>{
          const [polyId,myriadId] = btn.getAttribute('data-edit').split('|');
          const p = (pairs||[]).find(x => String(x.polyId)===polyId && String(x.myriadId)===myriadId);
          if(!p) return;
          polyEl.value = p.polyId; myrEl.value = p.myriadId;
          dirEl.value = p.direction||'same'; mapEl.value = JSON.stringify(p.map||[], null, 2);
          notesEl.value = p.notes||'';
          window.scrollTo({top:0,behavior:'smooth'});
        };
      });
      ok(msgEl, `${pairs.length} pairs`);
    }catch(e){ err(msgEl, e.message); }
  }

  // -------- Outcome Map Builder UI --------
  async function buildMapUI(){
    const polyId = polyEl.value.trim(), myrId = myrEl.value.trim();
    if(!polyId || !myrId){ err(msgEl,'Set Polymarket ID and Myriad ID first'); return; }

    mapWrap.style.display = 'block';
    mapWrap.open = true;
    mapInner.textContent = 'Loading choices…';

    // get poly outcomes
    let polyOut = [];
    try {
      const meta = BY_ID[String(polyId)];
      if (meta && meta.outcomes) {
        polyOut = typeof meta.outcomes==='string' ? JSON.parse(meta.outcomes) : meta.outcomes;
      }
      if (!polyOut?.length) {
        const detail = await xfetch(`${CLOB}/markets/${polyId}`);
        if (Array.isArray(detail?.tokens)) {
          polyOut = detail.tokens.map(t => t.name || t.label || t.ticker || t.outcome).filter(Boolean);
        }
      }
    } catch(_) {}

    // get myriad outcomes
    let myrOut = [];
    try {
      const detail = await xfetch(`${MYRIAD_BASE}/${myrId}?network_id=274133`);
      const obj = detail && detail.data ? detail.data : detail;
      if (Array.isArray(obj?.outcomes)) myrOut = obj.outcomes.map(o=>o.title||o.name);
      if (!myrOut.length) {
        const maybe = await xfetch(`${MYRIAD_BASE}/${myrId}/outcomes?network_id=274133`);
        const arr = Array.isArray(maybe) ? maybe : (Array.isArray(maybe?.data)?maybe.data:[]);
        myrOut = arr.map(o=>o.title||o.name);
      }
    } catch(_) {}

    if(!polyOut.length || !myrOut.length){
      mapInner.innerHTML = `<span class="muted">Could not load all choices. Poly: ${polyOut.length}, Myriad: ${myrOut.length}</span>`;
      return;
    }

    // Build rows: for each poly choice, select matching myriad choice
    const current = (()=>{ try{ return JSON.parse(mapEl.value||'[]'); }catch{ return []; } })();
    const mapByPoly = new Map(current.map(x=>[String(x.poly), x.myriad]));

    const wrap = document.createElement('div');
    wrap.innerHTML = `
      <div class="muted" style="margin-bottom:6px;">Pick a Myriad choice for each Polymarket choice. The JSON will be written to the Outcome map box.</div>
      <table class="mini"><thead><tr><th>Polymarket choice</th><th>→</th><th>Myriad choice</th></tr></thead><tbody></tbody></table>
      <div style="margin-top:8px;"><button id="mbWrite">Write to Outcome map</button> <span class="muted" id="mbMsg"></span></div>
    `;
    const body = wrap.querySelector('tbody');

    const selects = [];
    polyOut.forEach(pLabel=>{
      const tr = document.createElement('tr');
      const sel = document.createElement('select');
      sel.style.minWidth = '220px';
      sel.innerHTML = `<option value="">— choose —</option>` + myrOut.map(m=>`<option value="${escapeHtml(m)}">${escapeHtml(m)}</option>`).join('');
      const pre = mapByPoly.get(String(pLabel));
      if (pre) sel.value = pre;
      tr.innerHTML = `<td>${escapeHtml(String(pLabel))}</td><td style="width:30px;">→</td><td></td>`;
      tr.children[2].appendChild(sel);
      body.appendChild(tr);
      selects.push({ poly:pLabel, sel });
    });

    mapInner.innerHTML = "";
    mapInner.appendChild(wrap);

    wrap.querySelector('#mbWrite').onclick = ()=>{
      const out = [];
      selects.forEach(({poly,sel})=>{
        if (sel.value) out.push({ poly:String(poly), myriad:String(sel.value) });
      });
      mapEl.value = JSON.stringify(out, null, 2);
      wrap.querySelector('#mbMsg').textContent = `Wrote ${out.length} mappings.`;
    };
  }

  createBtn.onclick = create; upsertBtn.onclick = upsert; delBtn.onclick = del; refBtn.onclick = refresh;
  buildBtn.onclick = buildMapUI;
  refresh();

  // quick row helper for prefilling IDs
  document.getElementById('tbody').addEventListener('click', (ev)=>{
    const tr = ev.target.closest('tr'); if(!tr) return;
    const idTd = tr.children[1]; const id = idTd?.textContent?.trim();
    const isPoly = (tr.querySelector('.chip')||{}).textContent?.includes('Polymarket');
    const isMyri = (tr.querySelector('.chip')||{}).textContent?.includes('Myriad');
    if(!id) return;
    if(isPoly) polyEl.value = id;
    if(isMyri) myrEl.value = id;
  });
})();

// ---------- Start message (no auto-fetch)
setStatus("Select a source, then press Refresh to load.");
</script>
</body>
</html>
