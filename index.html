<script>
// ================================
// Browser → Polymarket → Worker (hybrid ingest)
// ================================
const POLY_GAMMA = "https://gamma-api.polymarket.com";

/** try direct; if CORS blocks, fall back to worker proxy:  GET {worker}?url=... */
async function gammaFetch(url) {
  try {
    const r = await fetch(url, { headers: { accept: "application/json" }});
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    return await r.json();
  } catch (e) {
    // fallback via worker proxy (your worker already allows this host)
    const proxied = `${getBase()}?url=${encodeURIComponent(url)}`;
    const r2 = await fetch(proxied, { headers: { accept: "application/json" }});
    if (!r2.ok) throw new Error(`Proxy HTTP ${r2.status}`);
    return await r2.json();
  }
}

/** POST one JSON chunk to the worker, which only writes to D1 */
async function postPolyChunkToWorker(marketsChunk) {
  // keep payload small—only fields Worker needs
  const slim = marketsChunk.map(m => ({
    id: String(m.id),
    question: m.question,
    slug: m.slug,
    endDateIso: m.endDateIso ?? m.endDate ?? null,
    outcomes: Array.isArray(m.outcomes) ? m.outcomes : (typeof m.outcomes === "string" ? (()=>{try{return JSON.parse(m.outcomes)}catch{return []}})() : []),
    raw: m, // optional: if your worker stores full JSON; remove if not
  }));
  return apiPost('/admin/ingest/polyPage', { markets: slim }, true);
}

/**
 * Hybrid ingest:
 * - Browser fetches Polymarket gamma pages
 * - Sends them to Worker in small POSTs
 * - Concurrency is for *gamma* page downloads only (safe in browser)
 */
async function ingestPolymarketFromBrowser({
  limit = 400,         // gamma page size
  max = 2000,          // maximum rows to fetch overall
  concurrency = 3,     // parallel gamma pages
  postChunk = 200      // how many markets per POST to worker
} = {}) {
  const out = $('ingMsg');
  if (!getBase()) { out.textContent = 'Set Worker URL first.'; out.className='muted err'; return; }
  if (!getToken()) { out.textContent = 'Paste your ADMIN_TOKEN first.'; out.className='muted err'; return; }

  out.textContent = 'Fetching Polymarket…'; out.className='muted';

  // build a queue of offsets (0, limit, 2*limit, …) up to max
  const offsets = [];
  for (let off = 0; off < max; off += limit) offsets.push(off);

  let totalReceived = 0;
  let totalStored   = 0;
  let stopEarly     = false;

  async function processOffset(offset) {
    if (stopEarly) return;
    const url = `${POLY_GAMMA}/markets?closed=false&limit=${limit}&offset=${offset}`;
    const page = await gammaFetch(url);
    const rows = Array.isArray(page) ? page : [];

    // if we got less than asked, likely the end—signal other workers to stop after current run
    if (rows.length < limit) stopEarly = true;

    // filter out expired/closed on the client too (just to shrink payloads)
    const today = new Date(); today.setHours(0,0,0,0);
    const fresh = rows.filter(g => {
      const end = g.endDateIso || g.endDate || null;
      return (!end || new Date(end) >= today) && !g.closed;
    });

    totalReceived += rows.length;

    // split into small POSTs so we never hit body size limits
    for (let i = 0; i < fresh.length; i += postChunk) {
      const slice = fresh.slice(i, i + postChunk);
      if (!slice.length) continue;
      const res = await postPolyChunkToWorker(slice);   // {ok, stored}
      totalStored += (res?.stored || slice.length);
      out.textContent = `Uploaded ${totalStored} (fetched ${totalReceived})…`;
    }
  }

  // run with limited concurrency
  const workers = new Array(concurrency).fill(null).map(async (_, i) => {
    for (let k = i; k < offsets.length; k += concurrency) {
      if (stopEarly) break;
      await processOffset(offsets[k]);
    }
  });

  try {
    await Promise.all(workers);
    out.textContent = `Done. Stored ${totalStored} (received ${totalReceived}).`; out.className='muted ok';
    OFFSET = 0;
    await loadFromDb();
  } catch (e) {
    out.textContent = 'Error: ' + e.message; out.className='muted err';
  }
}

// ---- wire the button to the new flow
$('btnIngestPoly').onclick = () =>
  ingestPolymarketFromBrowser({ limit: 400, max: 2000, concurrency: 3, postChunk: 200 });
</script>
